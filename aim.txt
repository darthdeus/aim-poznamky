# i386, 32b mod, linearni adresy, uzivatelsky mod

- int 8, 16, 32, (64) ... napr. pri nasobeni dvou 32b cisel muzeme mit 64b vysledek
- dvojkovy doplnek
- little endian
  - 0x12345678 se zapise jako | 78 | 56 | 34 | 12 |
- float 32(24b mantisa), 64(53), 80(64), [16(11)] jen ve vektorovych
  instrukcich, hodi se napr na 3d grafiku nebo na zpracovani HDR fotek
- vektory 128, (256)
- pamet rozdelena od 0 do 2^32-1 (man 3 mmap, munmap)

- EAX |
- EBX | "universalni"
- ECX |
- EDX |
---------------------
- ESI | source/dest.
- EDI |    index
---------------------
- EBP - base pointer, zacatek lokalnich promennych
- ESP - stack pointer, nejnizsi misto v pameti, ktere patri zasobniku (vrchol zasobniku)
- EIP - instruction pointer, aktualni pozice programu v pameti
      - behem provadeni instrukce je to adresa odkud se bude nacitat dalsi instrukce
      - nemusi ani existovat, nic se s nim delat neda
- EFLAGS - Z: predchozi operace nula (zero), C: preteceni (carry), S: predchozi
              operace zaporne cislo (sign), D: ovlivnuje, jestli se po pameti chodi popredu
              nebo pozpatku
         - nastavuji je bezne instrukce
         - instrukce podmineneho skoku muzou vyuzit hodnoy flagu

- floatove registry tvori 8-registrovy zasobnik
- floatovy zasobnik ST(0) ... ST(7)
- do kazdeho se vejde 80b float
- indexuji se cyklicky
- operace ctou prvni operand z ST(0) a druhy odkudkoliv, a zapisou zpatky do ST(0)
- FPUCR, FPUSR - ridici a stavovy floatovy registr
               - floatove stavy jsou kumulativni, muzu kontrolovat az po vice operacich

- XMM0 - XMM7 (128b)
- YMM0 - YMM7 (256b)
- MXCSR - ridici a stavovy registr pro vektorove registry

Intel: ADD EAX,7
AT&T:  addl $7,%eax

8  - b
16 - w
32 - l
64 - q

- poradi prirazeni je opacne, dest. je napravo
- % se pise pred registr, $ pred literal (konstantu zadratovanou do instrukce)
- $7 je konstanta 7, 7 je reference na obsah pameti na adrese 7 (u intelu se pise [7])
- explicitni velikost

addl $7,(%eax)
ADD  DWORD PTR [EAX], 7

4(%eax) - vezmi obsah eax, k nemu pricti 4, a vyjde adresa kde najdes to, s cim se pocita
4(%eax, %ecx, 2) - pristup na adresu [eax + 2*ecx + 4], hodi se pri adresovani indexem

# ABI (Application Binary Interface) i386, C a Linux

- lisi se architekturou, jazykem a operacnim systemem
- konvence rika, ze na 0 neni namapovana zadna pamet
- vsechno co jde, se predava pres zasobnik
- f(int x, int y)
  - nejdriv na zasobnik vlozi y
  - pak na zasobnik vlozi x
  - predava se po 4B slotech (80b floaty zabiraji 3 sloty)
- volajici pouziva instrukci call
  - skoci na adresu podprogramu
  - na zasobnik vlozi navratovou adresu


         |               | |
         |               | |
         ----------------- |
      +12| x             | |
         ----------------- |
ulozi +8 | y             | | volajici
volajici ----------------- |
ESP ->+4 | navrat adresa | -
         -----------------
EBP ->+0 | stare EBP     | -
         ----------------- |
         | lokalni       | | volany
         | promenne      | |
         ----------------- |
         | pracovni      | |
         | prostor       | -

         -----------------
         | red zone      | na amd64 mame 128b pod stack pointerem, nemusi se hybat stack pointerem

volajici odstranuje argumenty, protoze volany nevi, kolik dostal argumentu (prvni argument je posledni dole)

- pokud je vysledek 32b, vraci se v EAX
- pokud je vysledek 64b, vraci se v EDX:EAX
- pokud je to float, vraci se v ST(0)
- pokud je to struktura, volajici si udela misto na zasobniku, a volany dostane
  0. argument, kde se preda adresa kam se to ma ulozit

# amd64

      b   w   l   q
- int 8, 16, 32, 64, (128)
- pamet je 2^64-1
- adresy muzou byt zaporne, pokud jsou zaporne tak je to pamet procesoru, kladne adresy jsou uzivatelske
-      RAX, RBX, RCX, RDX, RSI, RDI, RBP, RSP, RIP
- nebo R0,   R1,  R2,  R3,  R4,  R5,  R6,  R7, ..., R15
- muzeme psat R8L, R8W, R0H
- da se relativne adresovat vuci RIP

- XMM0-7 se rozsiruje na XMM15 (stejne tak YMM15)

- leave (odrolovani zasobniku)


# druhy pameti

- staticka: klopny obvod, rychly, velka bunka (nemuzeme jich mit hodne)
- dynamicka: jeden kodenzator, ctenim se vybije, musi se znovu nahrat, casem se
  vybiji (protoze nemame nekonecne velky odpor), tzn. musi se refreshovat

## cache plne asociativni

- [ adresa, data ]
- radky po 64B [ tag 26b | pos 6b ]
- cache si pamatuje jenom tagy, tzn. [ tag | data ]

- LRU (Least-Recently Used)

- write-through zapisy
  - zapisy se zapisuji skrz cache, tzn. je vzdycky koherentni,
  - zapis ale blokuje nez se zapise do hlavni pameti, tzn je pomalejsi a cache zrychluje jenom cteni

- write-back zapisy
  - v cache je dirty bit

## primo adresovana cache (directly mapped)

- h(adresa) -> radek
- 64kB cache s 64B radky -> 1024 radku -> 10b index
- [ tag | index 10 | pos 6 ]

## k-cestne mnozinove asociativni cache

- h(adresa) -> mnozina s $k$ radky
- 64kB, 4-cestna, 1024 radku -> 256 mnozin -> index ma 8b
- [ tag 18b | index 8b | pos 6b ]

## Intel Core 2 Duo

- L1I 32kB 4-cestna
- L1D 32kB 8-cestna
- L2   2MB 8-cestna


# Memory Management Unit

----        ----
|  |  MMU   |  |
|--| -----> |--|
|  |        |  |
|--|        |--|
|  |        |  |
----        ----
 VA          PA

stranky 4kB

- [ i1 10 | i2 10 | pos 12 ]
- registr CR2, ktery odkazuje na koren strankoveho stromu
- pouzije se prvnich 10b na nalezeni stranky druhe urovne
  - bud se dalsich 10b pouzije na dalsi uroven strankovaciho stromu,
    kde se uz najde samotny preklad
  - nebo se adresuje primo prvni urovni, pak jsou stranky 4MB

# TLB (Translation Look-aside Buffer)

- udrzi si radove stovky prekladu pomoci hornich 20b adresy (dolnich 12b je adresa v ramci stranky)
- TLB je casto viceurovnove

# virtualne indexovana, fyzicky tagovana

- 32kB 8-cestna
- 512 radku, 64 mnozin
- [ tag | idx 6 | pos 6 ]
- muzu paralelne zadat TLB preklad pomoci hornich 20b a L1D pomoci dolnich 12b


# DRAM

- matice, ne pole
- pamet se cte nejprve do radkoveho bufferu (pak pres PRECHARGE zpatky)

- L1_DTLB_MISS_AND_L2_DTLB_HIT


# DU

- na strankach prednasky je ke stazeni program ktery grafy z prednasky
  generuje, vyzkouset co to dela, zkusit vestit z krivek :)
