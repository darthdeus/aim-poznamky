# i386, 32b mod, linearni adresy, uzivatelsky mod

- int 8, 16, 32, (64) ... napr. pri nasobeni dvou 32b cisel muzeme mit 64b vysledek
- dvojkovy doplnek
- little endian
  - 0x12345678 se zapise jako | 78 | 56 | 34 | 12 |
- float 32(24b mantisa), 64(53), 80(64), [16(11)] jen ve vektorovych
  instrukcich, hodi se napr na 3d grafiku nebo na zpracovani HDR fotek
- vektory 128, (256)
- pamet rozdelena od 0 do 2^32-1 (man 3 mmap, munmap

- EAX |
- EBX | "universalni"
- ECX |
- EDX |
---------------------
- ESI | source/dest.
- EDI |    index
---------------------
- EBP - base pointer, zacatek lokalnich promennych
- ESP - stack pointer, nejnizsi misto v pameti, ktere patri zasobniku (vrchol zasobniku)
- EIP - instruction pointer, aktualni pozice programu v pameti
      - behem provadeni instrukce je to adresa odkud se bude nacitat dalsi instrukce
      - nemusi ani existovat, nic se s nim delat neda
- EFLAGS - Z: predchozi operace nula (zero), C: preteceni (carry), S: predchozi
              operace zaporne cislo (sign), D: ovlivnuje, jestli se po pameti chodi popredu
              nebo pozpatku
         - nastavuji je bezne instrukce
         - instrukce podmineneho skoku muzou vyuzit hodnoy flagu

- floatove registry tvori 8-registrovy zasobnik
- floatovy zasobnik ST(0) ... ST(7)
- do kazdeho se vejde 80b float
- indexuji se cyklicky
- operace ctou prvni operand z ST(0) a druhy odkudkoliv, a zapisou zpatky do ST(0)
- FPUCR, FPUSR - ridici a stavovy floatovy registr
               - floatove stavy jsou kumulativni, muzu kontrolovat az po vice operacich

- XMM0 - XMM7 (128b)
- YMM0 - YMM7 (256b)
- MXCSR - ridici a stavovy registr pro vektorove registry

Intel: ADD EAX,7
AT&T:  addl $7,%eax

8  - b
16 - w
32 - l
64 - q

- poradi prirazeni je opacne, dest. je napravo
- % se pise pred registr, $ pred literal (konstantu zadratovanou do instrukce)
- $7 je konstanta 7, 7 je reference na obsah pameti na adrese 7 (u intelu se pise [7])
- explicitni velikost

addl $7,(%eax)
ADD  DWORD PTR [EAX], 7

4(%eax) - vezmi obsah eax, k nemu pricti 4, a vyjde adresa kde najdes to, s cim se pocita
4(%eax, %ecx, 2) - pristup na adresu [eax + 2*ecx + 4], hodi se pri adresovani indexem

# ABI (Application Binary Interface) i386, C a Linux

- lisi se architekturou, jazykem a operacnim systemem
- konvence rika, ze na 0 neni namapovana zadna pamet
- vsechno co jde, se predava pres zasobnik
- f(int x, int y)
  - nejdriv na zasobnik vlozi y
  - pak na zasobnik vlozi x
  - predava se po 4B slotech (80b floaty zabiraji 3 sloty)
- volajici pouziva instrukci call
  - skoci na adresu podprogramu
  - na zasobnik vlozi navratovou adresu


         |               | |
         |               | |
         ----------------- |
      +12| x             | |
         ----------------- |
ulozi +8 | y             | | volajici
volajici ----------------- |
ESP ->+4 | navrat adresa | -
         -----------------
EBP ->+0 | stare EBP     | -
         ----------------- |
         | lokalni       | | volany
         | promenne      | |
         ----------------- |
         | pracovni      | |
         | prostor       | -

         -----------------
         | red zone      | na amd64 mame 128b pod stack pointerem, nemusi se hybat stack pointerem

volajici odstranuje argumenty, protoze volany nevi, kolik dostal argumentu (prvni argument je posledni dole)

- pokud je vysledek 32b, vraci se v EAX
- pokud je vysledek 64b, vraci se v EDX:EAX
- pokud je to float, vraci se v ST(0)
- pokud je to struktura, volajici si udela misto na zasobniku, a volany dostane
  0. argument, kde se preda adresa kam se to ma ulozit

# amd64

      b   w   l   q
- int 8, 16, 32, 64, (128)
- pamet je 2^64-1
- adresy muzou byt zaporne, pokud jsou zaporne tak je to pamet procesoru, kladne adresy jsou uzivatelske
-      RAX, RBX, RCX, RDX, RSI, RDI, RBP, RSP, RIP
- nebo R0,   R1,  R2,  R3,  R4,  R5,  R6,  R7, ..., R15
- muzeme psat R8L, R8W, R0H
- da se relativne adresovat vuci RIP

- XMM0-7 se rozsiruje na XMM15 (stejne tak YMM15)

- leave (odrolovani zasobniku)
